---
title: "R Notebook"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "~/Research/ldreg")
knitr::opts_chunk$set(echo = F)
```

The goal of this analysis is to drill down further into the apparent disappearence of our power. 

```{r}
library(ggplot2)
library(foreach)
library(dplyr)

true_upsilon <- c(-2.84507392318969e-05, -3.35384263223196e-05, 4.43856550207098e-05)
```

# Old Non-Null Results

Checking the old save files, we can see that it __was__ estimating values relatively well.

```{r, eval = T}
jack <- readRDS("output/old/test_non_null.output.jack_wt.all.rds")
foreach(i = 1:100, .combine = bind_rows) %do% 
{
  jack[[i]] %>% 
    as.data.frame() %>% 
    tibble::rownames_to_column(var = "group") %>% 
    mutate(index = i)
} %>% 
{
  ggplot(data = ., aes(x = upsilon_hat, color = group)) +
    geom_density() +
    theme_bw()
}

```

#Current Version (Problems)

But now it isn't.

```{r, eval = T}
.tmp <- foreach(r = c("emp", "true"), .combine = bind_rows) %:%
  foreach(wt = c("nowt", "wt"), .combine = bind_rows) %:%
  foreach(i = 1:100, .combine = bind_rows, .errorhandling = "remove") %do% {
    jack <- readRDS(sprintf("Output/pass_true_r_non_null/2016-11-30b/out/jack.%s.%s.%s.rds", wt, r, i))
    jack %>% 
      as.data.frame() %>% 
      tibble::rownames_to_column(var = "group") %>% 
      tidyr::gather("var", "value", -group) %>% 
      mutate(index = i, wt = (wt == "wt"), r = r)
  } %>% 
  mutate(group = readr::parse_number(group),
         true_val = true_upsilon[group])
.tmp %>%
  tidyr::spread(var, value) %>% 
  mutate(cover_zero = (estim - 2*se < 0) & (estim + 2*se > 0),
         cover_true = (estim - 2*se < true_val) & (estim + 2*se > true_val),
         group = readr::parse_number(group)) %>% 
  group_by(wt, r, group) %>% 
  summarize(
    "CI Cov 0" = scales::percent(mean(cover_zero)),
    "CI Cov True" = scales::percent(mean(cover_true)),
    "Avg J.Est" = mean(estim),
    "Avg Est" = mean(upsilon_hat),
    "J.Bias" = mean(estim - true_val),
    "Bias" = mean(upsilon_hat - true_val),
    "Avg J.SE" = mean(se),
    "SD J.Est" = sd(estim),
    "SD Est" = sd(upsilon_hat)
  ) %>% 
  {knitr::kable(.)}
```

```{r, eval = T}
ggplot(data = .tmp %>% 
         tidyr::spread(var, value)) +
  geom_density(aes(x = upsilon_hat, color = factor(group), linetype = wt)) +
  geom_vline(aes(xintercept = true_val, color = factor(group))) +
  theme_bw() +
  labs(x = "Estimated Upsilon", title = "Density Plot of Estimates")
  
```

What happened?

# Git revert

We start with a set of results from `test_non_null.R` that used a branched version of the package code from just before the last known time non-null tests could pick up the effects with apparent accuracy. Note that only the code controlling the fits has been reverted - all the other code is still the same as the master branch at this time.

```{r, eval = T}

true_upsilon <- c(-2.84507392318969e-05, -3.35384263223196e-05, 4.43856550207098e-05)

.tmp <- foreach(wt = c("", "_wt"), .combine = bind_rows) %:%
  foreach(i = 1:100, .combine = bind_rows, .errorhandling = "remove") %do% {
    jack <- readRDS(sprintf("Output/test_non_null/2016-12-04a/out/jack%s.%s.rds", wt, i))
    jack %>% 
      as.data.frame() %>% 
      tibble::rownames_to_column(var = "group") %>% 
      tidyr::gather("var", "value", -group) %>% 
      mutate(index = i, wt = (wt == "_wt"))
  } %>% 
  mutate(group = readr::parse_number(group),
         true_val = true_upsilon[group])
.tmp %>%
  tidyr::spread(var, value) %>% 
  mutate(cover_zero = (estim - 2*se < 0) & (estim + 2*se > 0),
         cover_true = (estim - 2*se < true_val) & (estim + 2*se > true_val),
         group = readr::parse_number(group)) %>% 
  group_by(wt, group) %>% 
  summarize(
    "CI Cov 0" = scales::percent(mean(cover_zero)),
    "CI Cov True" = scales::percent(mean(cover_true)),
    "Avg J.Est" = mean(estim),
    "Avg Est" = mean(upsilon_hat),
    "J.Bias" = mean(estim - true_val),
    "Bias" = mean(upsilon_hat - true_val),
    "Avg J.SE" = mean(se),
    "SD J.Est" = sd(estim),
    "SD Est" = sd(upsilon_hat)
  ) %>% 
  {knitr::kable(.)}
  #{print(xtable::xtable(., ""), type = "html")}
```

In the plot below, the vertical lines indicate the true (non-null) values of $\upsilon$ for each group.

```{r, eval = T}
ggplot(data = .tmp %>% 
         tidyr::spread(var, value)) +
  geom_density(aes(x = upsilon_hat, color = factor(group), linetype = wt)) +
  geom_vline(aes(xintercept = true_val, color = factor(group))) +
  theme_bw() +
  labs(x = "Estimated Upsilon", title = "Density Plot of Estimates")
  
```

There are significant outliers evident in the distribution of estimates. Let's take a closer look to see whether the mode of the estimates is accurate.

```{r}
ggplot(data = .tmp %>% 
         tidyr::spread(var, value)) +
  geom_density(aes(x = upsilon_hat, color = factor(group), linetype = wt)) +
  geom_vline(aes(xintercept = true_val, color = factor(group))) +
  theme_bw() +
  labs(x = "Estimated Upsilon", title = "Density Plot of Estimates") +
  scale_x_continuous(limits = 5 * c(-1, 1))
```

The estimates seem to be picking up a non-null effect, and the groups even seem to line up in the right way with each other, but the estimates are way too large. The cause is the `getfit` function, which is actually estimating correlations right now. 

```
getfit <- function(z1, z2, r, cat_mems, N1, N2, weighted = FALSE, ...) {
  ld <- lapply(cat_mems, function(.) colSums((r^2)[.,]))
  dat <- as.data.frame(ld)
  names(dat) <- paste0("ld", 1:length(ld))
  rhs <- paste(names(dat), collapse = "+")
  dat$zz <- z1 * z2
  wt <- if (weighted) {1 / (var(dat$zz) * colSums(r^2))} else NULL
  fit <- lm(data = dat, formula(paste0("zz ~ ", rhs)), weights = wt)
  upsilon <- coef(fit)[-1] / sqrt(N1 * N2)

  tau1 <- getfit_strat(z1^2, r, cat_mems, N1)
  tau2 <- getfit_strat(z2^2, r, cat_mems, N2)

  upsilon / sqrt(abs(tau1 * tau2))
}
```

We'll fix this and stage a new commit, then see if the outliers are still there.

#New output

```{r}

.tmp <- foreach(wt = c("", "_wt"), .combine = bind_rows) %:%
  foreach(i = 1:100, .combine = bind_rows, .errorhandling = "remove") %do% {
    jack <- readRDS(sprintf("Output/test_non_null/2016-12-09a/out/jack%s.%s.rds", wt, i))
    jack %>% 
      as.data.frame() %>% 
      tibble::rownames_to_column(var = "group") %>% 
      tidyr::gather("var", "value", -group) %>% 
      mutate(index = i, wt = (wt == "_wt"))
  } %>% 
  mutate(group = readr::parse_number(group),
         true_val = true_upsilon[group])
.tmp %>%
  tidyr::spread(var, value) %>% 
  mutate(cover_zero = (estim - 2*se < 0) & (estim + 2*se > 0),
         cover_true = (estim - 2*se < true_val) & (estim + 2*se > true_val),
         group = readr::parse_number(group)) %>% 
  group_by(wt, group) %>% 
  summarize(
    "CI Cov 0" = scales::percent(mean(cover_zero)),
    "CI Cov True" = scales::percent(mean(cover_true)),
    "Avg J.Est" = mean(estim),
    "Avg Est" = mean(upsilon_hat),
    "J.Bias" = mean(estim - true_val),
    "Bias" = mean(upsilon_hat - true_val),
    "Avg J.SE" = mean(se),
    "SD J.Est" = sd(estim),
    "SD Est" = sd(upsilon_hat)
  ) %>% 
  {knitr::kable(.)}

ggplot(data = .tmp %>% 
         tidyr::spread(var, value)) +
  geom_density(aes(x = upsilon_hat, color = factor(group), linetype = wt)) +
  geom_vline(aes(xintercept = true_val, color = factor(group))) +
  theme_bw() +
  labs(x = "Estimated Upsilon", title = "Density Plot of Estimates")

```

This adjustment makes the outliers go away. A side by side comparison of the `getfit` functions shows that there are two differences: the use of bias correction, and the modifications to jackknife procedures that look for the best points to break the blocks on. 

#Bias Correction

First, we'll try reintroducing the bias correction to see if the problem reapppears.


```{r}

.tmp <- foreach(wt = c("", "_wt"), .combine = bind_rows) %:%
  foreach(i = 1:100, .combine = bind_rows, .errorhandling = "remove") %do% {
    jack <- readRDS(sprintf("Output/test_non_null/2016-12-10/out/jack%s.%s.rds", wt, i))
    jack %>% 
      as.data.frame() %>% 
      tibble::rownames_to_column(var = "group") %>% 
      tidyr::gather("var", "value", -group) %>% 
      mutate(index = i, wt = (wt == "_wt"))
  } %>% 
  mutate(group = readr::parse_number(group),
         true_val = true_upsilon[group])
.tmp %>%
  tidyr::spread(var, value) %>% 
  mutate(cover_zero = (estim - 2*se < 0) & (estim + 2*se > 0),
         cover_true = (estim - 2*se < true_val) & (estim + 2*se > true_val),
         group = readr::parse_number(group)) %>% 
  group_by(wt, group) %>% 
  summarize(
    "CI Cov 0" = scales::percent(mean(cover_zero)),
    "CI Cov True" = scales::percent(mean(cover_true)),
    "Avg J.Est" = mean(estim),
    "Avg Est" = mean(upsilon_hat),
    "J.Bias" = mean(estim - true_val),
    "Bias" = mean(upsilon_hat - true_val),
    "Avg J.SE" = mean(se),
    "SD J.Est" = sd(estim),
    "SD Est" = sd(upsilon_hat)
  ) %>% 
  {knitr::kable(.)}

ggplot(data = .tmp %>% 
         tidyr::spread(var, value)) +
  geom_density(aes(x = upsilon_hat, color = factor(group), linetype = wt)) +
  geom_vline(aes(xintercept = true_val, color = factor(group))) +
  theme_bw() +
  labs(x = "Estimated Upsilon", title = "Density Plot of Estimates")

```

This suggests that it's the block finding for jackknife that's interfering with the non-null outcomes.

#Jackknife Block Finding

Going back to master branch, we'll test this by saving out the jackknife block divisions to take a further look.

```{r}

.tmp <- foreach(i = 1:100, .combine = bind_rows, .errorhandling = "remove") %do% {
    jack <- readRDS(sprintf("Output/test_non_null/2016-12-11b/out/jack%s.%s.rds", wt, i))
    jack %>% 
      as.data.frame() %>% 
      tibble::rownames_to_column(var = "group") %>% 
      tidyr::gather("var", "value", -group) %>% 
      mutate(index = i)
  } %>% 
  mutate(group = readr::parse_number(group),
         true_val = true_upsilon[group])
.tmp %>%
  tidyr::spread(var, value) %>% 
  mutate(cover_zero = (estim - 2*se < 0) & (estim + 2*se > 0),
         cover_true = (estim - 2*se < true_val) & (estim + 2*se > true_val),
         group = readr::parse_number(group)) %>% 
  group_by(group) %>% 
  summarize(
    "CI Cov 0" = scales::percent(mean(cover_zero)),
    "CI Cov True" = scales::percent(mean(cover_true)),
    "Avg J.Est" = mean(estim),
    "Avg Est" = mean(upsilon_hat),
    "J.Bias" = mean(estim - true_val),
    "Bias" = mean(upsilon_hat - true_val),
    "Avg J.SE" = mean(se),
    "SD J.Est" = sd(estim),
    "SD Est" = sd(upsilon_hat)
  ) %>% 
  {knitr::kable(.)}

ggplot(data = .tmp %>% 
         tidyr::spread(var, value)) +
  geom_density(aes(x = upsilon_hat, color = factor(group))) +
  geom_vline(aes(xintercept = true_val, color = factor(group))) +
  theme_bw() +
  labs(x = "Estimated Upsilon", title = "Density Plot of Estimates")

```

Okay, soooooooo... now the code on the master branch is producing non-weird results. No substantive changes made since the wacky results, though.
